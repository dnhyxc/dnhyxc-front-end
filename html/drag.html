<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Document</title>
		<style>
			body {
				background-color: #3c3c3c;
			}
			#box {
				cursor: pointer;
			}
		</style>
	</head>
	<body>
		<div id="box" draggable="true">111</div>

		<script lang="ts">
			// var maxProfit = function (prices) {
			// 	// 边界条件：如果数组为空或只有一天的数据，无法获得利润
			// 	if (prices.length <= 1) return 0;
			// 	let minPrice = prices[0]; // 初始时，最低价格就是第一天的价格
			// 	let maxProfit = 0; // 初始时，利润为 0
			// 	// 遍历数组中的每个价格
			// 	for (let i = 1; i < prices.length; i++) {
			// 		console.log(prices[i] - minPrice, "prices[i] - minPrice");
			// 		// 如果当前价格减去最低价格能获得更高的利润，则更新最大利润
			// 		maxProfit = Math.max(maxProfit, prices[i] - minPrice);
			// 		// 更新最低价格
			// 		minPrice = Math.min(minPrice, prices[i]);
			// 	}
			// 	return maxProfit;
			// };

			// const muns = [7, 1, 5, 3, 6, 4];
			// console.log(maxProfit(muns), "maxProfit");

			/**
			 * 买卖股票的最佳时机 II
			 * @param {number[]} prices
			 * @return {number}
			 */
			// var maxProfit = function (prices) {
			// 	// 获取股票价格数组的长度
			// 	const n = prices.length;
			// 	// 初始化动态规划数组，用于存储每天的最大利润
			// 	const dp = new Array(n).fill(0).map((v) => new Array(2).fill(0));
			// 	// 初始化第一天的状态
			// 	dp[0][0] = 0; // 第一天不持有股票的最大利润为0
			// 	dp[0][1] = -prices[0]; // 第一天持有股票的最大利润为负的股票价格
			// 	// 从第二天开始遍历
			// 	for (let i = 1; i < n; ++i) {
			// 		// 如果第i天不持有股票，最大利润是前一天不持有股票的最大利润和前一天持有股票卖出后得到的最大利润的最大值
			// 		dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
			// 		// 如果第i天持有股票，最大利润是前一天持有股票的最大利润和前一天不持有股票买入后得到的最大利润的最大值
			// 		dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
			// 	}
			// 	// 返回最后一天不持有股票的最大利润
			// 	return dp[n - 1][0];
			// };

			// // 示例1：股票价格数组
			// const prices = [7, 1, 5, 3, 6, 4];
			// console.log(maxProfit(prices)); // 输出最大利润

			// // 示例2：股票价格数组
			// const prices1 = [1, 2, 3, 4, 5];
			// console.log(maxProfit(prices1)); // 输出最大利润

			/**
			 * 判断是否可以从数组的第一个元素跳到最后一个元素
			 * @param {number[]} nums - 包含每个元素可以跳跃的最大步数的数组
			 * @return {boolean} - 如果可以到达最后一个元素，返回 true，否则返回 false
			 */
			function canJump(nums) {
				// 初始化最远可达位置为 0，即最远的下标为 0
				let farthest = 0;

				// 遍历数组，更新最远可达位置
				for (let i = 0; i < nums.length; i++) {
					// 如果当前位置不可达，返回 false
					if (i > farthest) return false;

					/**
					 * 更新最远可达位置，取当前位置加上当前位置的跳跃步数
					 * 假设当前位置 i 的值是 nums[i]，它表示从下标 i 开始，最多可以跳跃 nums[i] 个位置。
					 * 例如，如果 nums[i] = 3，表示你从位置 i 可以跳到位置 i + 1、i + 2、i + 3 等，最多可以到达 i + 3。
					 * 所以，i + nums[i] 就是当前位置 i 能到达的最远位置。
					 * 如果这个最远位置比当前记录的 farthest（当前能到达的最远位置）还远，我们就更新 farthest。
					 */
					farthest = Math.max(farthest, i + nums[i]);

					// 如果可以到达最后一个下标，返回 true
					if (farthest >= nums.length - 1) return true;
				}

				// 如果遍历完整个数组都没有返回 true，则返回 false
				return false;
			}
		</script>
	</body>
</html>
